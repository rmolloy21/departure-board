<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>London Departure Boards</title>

  <style>
    :root{
      --bg: #0b0d10;
      --card: #12161c;
      --muted: #9aa4b2;
      --text: #e7eef8;
      --accent: #ffd400; /* departure-board yellow */
      --line: #2a3240;
      --danger: #ff6b6b;
      --ok: #4ade80;

      --navy: rgba(9, 18, 38, 0.65);
      --shadow: 0 6px 18px rgba(0,0,0,0.18);

      /* ticker duration is set dynamically in JS */
      --tickerDuration: 40s;
    }
    @media (prefers-color-scheme: light) {
      :root{
        --bg: #f6f7fb;
        --card: #ffffff;
        --muted: #556273;
        --text: #0b1220;
        --line: #e6eaf0;
        --accent: #111827;
        --navy: rgba(240, 243, 248, 1);
        --shadow: 0 6px 18px rgba(0,0,0,0.08);
      }
    }

    body{
      margin:0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    .phone{
      max-width: 430px;
      margin: 0 auto;
      padding: 14px 14px 28px;
    }

    header{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      margin-bottom: 10px;
    }
    .title{ line-height:1.1; }
    .title h1{
      font-size: 18px;
      margin: 4px 0 2px;
      font-weight: 900;
      letter-spacing: 0.2px;
    }
    .title .sub{
      font-size: 12px;
      color: var(--muted);
    }

    .topButtons{
      display:flex;
      flex-direction:column;
      gap:8px;
      align-items:flex-end;
      min-width: 150px;
    }
    .row{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      justify-content:flex-end;
    }

    button, select{
      background: var(--card);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 9px 10px;
      font-size: 13px;
      outline:none;
    }
    button{ cursor:pointer; }
    button.primary{
      border-color: transparent;
      background: var(--accent);
      color: #0b0d10;
      font-weight: 900;
    }
    button.icon{
      width: 40px;
      padding: 9px 0;
      text-align:center;
      font-weight: 900;
    }

    .pill{
      font-size: 12px;
      color: var(--muted);
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 6px 10px;
      display:inline-flex;
      gap:8px;
      align-items:center;
      background: rgba(255,255,255,0.02);
      margin-bottom: 10px;
    }
    .dot{
      width:8px; height:8px; border-radius:999px; background: var(--muted);
      display:inline-block;
    }

    /* Ticker */
    .tickerWrap{
      border: 1px solid var(--line);
      background: var(--card);
      border-radius: 14px;
      overflow:hidden;
      box-shadow: var(--shadow);
      margin-bottom: 12px;
    }
    .tickerHeader{
      padding: 10px 12px;
      border-bottom: 1px solid var(--line);
      background: var(--navy);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .tickerHeader .label{
      font-weight: 900;
      font-size: 13px;
      letter-spacing: 0.2px;
      white-space: nowrap;
    }
    .tickerHeader .meta{
      font-size: 12px;
      color: var(--muted);
      white-space: nowrap;
    }
    .tickerBody{
      padding: 10px 0;
      overflow:hidden;
    }
    .tickerTrack{
      display:inline-block;
      white-space: nowrap;
      will-change: transform;
      animation: scrollLeft var(--tickerDuration) linear infinite;
      padding-left: 100%;
    }
    .tickerItem{
      display:inline-block;
      margin: 0 18px;
      font-size: 12.5px;
    }
    .statusGood{ color: var(--ok); font-weight: 800; }
    .statusBad{ color: var(--danger); font-weight: 800; }
    @keyframes scrollLeft{
      0%{ transform: translateX(0); }
      100%{ transform: translateX(-100%); }
    }

    /* Boards list */
    .boards{
      display:flex;
      flex-direction:column;
      gap: 12px;
      margin-top: 6px;
    }
    .board{
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 14px;
      overflow:hidden;
      box-shadow: var(--shadow);
    }

    /* Drag hint when dragging */
    .board.dragging{
      opacity: 0.55;
    }
    .board.dropTarget{
      outline: 2px dashed var(--accent);
      outline-offset: 3px;
    }

    .boardHeader{
      padding: 12px 12px 10px;
      border-bottom: 1px solid var(--line);
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-start;
      background: var(--navy);
      cursor: grab;
    }
    .boardHeader:active{
      cursor: grabbing;
    }

    .boardHeader .left{ min-width: 0; }
    .boardHeader .name{
      font-weight: 900;
      font-size: 14px;
      letter-spacing: 0.2px;
      margin-bottom: 2px;
      white-space: nowrap;
      overflow:hidden;
      text-overflow: ellipsis;
    }
    .boardHeader .meta{
      font-size: 12px;
      color: var(--muted);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .boardHeader .right{
      display:flex;
      gap:8px;
      align-items:flex-start;
    }
    .smallBtn{
      font-size: 12px;
      padding: 7px 9px;
      border-radius: 10px;
    }
    .ghostBtn{
      background: transparent;
      border: 1px solid var(--line);
      color: var(--text);
    }

    .boardBody{ padding:0; }

    .table{
      width:100%;
      border-collapse: collapse;
      font-size: 12.5px;
    }
    .table td{
      padding: 8px 12px;
      border-bottom: 1px solid var(--line);
      vertical-align: top;
    }
    .table tr:last-child td{ border-bottom:none; }
    .dest{ font-weight: 900; margin-bottom: 1px; }
    .subline{
      color: var(--muted);
      font-size: 11px;
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .time{
      text-align:right;
      font-variant-numeric: tabular-nums;
      white-space:nowrap;
      font-weight: 900;
      width: 1%;
    }

    .boardFooter{
      padding: 10px 12px;
      border-top: 1px solid var(--line);
      font-size: 12px;
      color: var(--muted);
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .badge{
      border: 1px solid var(--line);
      border-radius: 999px;
      padding: 6px 10px;
      font-size: 12px;
      background: rgba(255,255,255,0.02);
    }
    .warn{ color: var(--danger); font-weight: 800; }
    .ok{ color: var(--ok); font-weight: 800; }

    .collapseToggle{
      cursor:pointer;
      user-select:none;
    }
    .collapsed .boardBody,
    .collapsed .boardFooter{
      display:none;
    }

    /* Modal */
    .modalBackdrop{
      display:none;
      position:fixed;
      inset:0;
      background:rgba(0,0,0,0.65);
      z-index:999;
      padding: 10px;
    }
    .modal{
      background: var(--card);
      max-width: 430px;
      margin: 10vh auto;
      border-radius: 14px;
      padding: 14px;
      border: 1px solid var(--line);
      box-shadow: var(--shadow);
    }
    .modalHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-bottom: 10px;
    }
    .modalHeader .h{
      font-weight: 900;
      font-size: 14px;
    }
    .modalGrid{
      display:flex;
      flex-direction:column;
      gap: 10px;
    }
    .fieldLabel{
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
      font-weight: 800;
      letter-spacing: 0.2px;
    }
    .field{
      display:flex;
      flex-direction:column;
      gap: 6px;
    }
    .input{
      padding: 10px;
      border-radius: 12px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,0.02);
      color: var(--text);
      font-size: 15px;
      outline:none;
    }
    @media (prefers-color-scheme: light) {
      .input{ background: #f6f7fb; }
    }
    .results{
      border: 1px solid var(--line);
      border-radius: 12px;
      overflow:hidden;
      background: rgba(255,255,255,0.01);
    }
    .resultItem{
      padding: 10px 10px;
      border-bottom: 1px solid var(--line);
      cursor:pointer;
    }
    .resultItem:last-child{ border-bottom:none; }
    .resultItem small{ color: var(--muted); }

    .checkRow{
      display:flex;
      gap:10px;
      align-items:center;
      padding: 8px 2px;
      user-select:none;
    }
    .checkRow input{
      width: 18px;
      height: 18px;
      accent-color: var(--accent);
    }
    .checkRow .txt{
      font-size: 13px;
      color: var(--text);
      font-weight: 800;
    }
    .checkRow .sub{
      font-size: 12px;
      color: var(--muted);
      font-weight: 600;
    }

    .footerNote{
      margin-top: 12px;
      color: var(--muted);
      font-size: 11.5px;
      line-height:1.35;
    }

    a{ color: inherit; }
  </style>
</head>

<body>
  <div class="phone">
    <header>
      <div class="title">
        <h1>London Departure Boards</h1>
        <div class="sub" id="statusText">Idle</div>
      </div>

      <div class="topButtons">
        <div class="row">
          <button class="smallBtn" id="nearestBtn">Nearest station</button>
          <button class="smallBtn" id="tubeMapBtn">Tube map</button>
        </div>
        <div class="row">
          <button class="primary icon" id="addBtn">+</button>
        </div>
      </div>
    </header>

    <div class="pill">
      <span class="dot" id="pulseDot"></span>
      <span>Auto-refresh: <strong id="refreshEvery">25s</strong> (while open)</span>
    </div>

    <!-- Line Status Ticker -->
    <section class="tickerWrap" id="tickerWrap" style="display:none;">
      <div class="tickerHeader">
        <div class="label">Line status</div>
        <div class="meta" id="tickerMeta">—</div>
      </div>
      <div class="tickerBody">
        <div class="tickerTrack" id="tickerTrack"></div>
      </div>
    </section>

    <!-- Boards -->
    <div class="boards" id="boards"></div>

    <div class="footerNote">
      Not affiliated with or endorsed by Transport for London. Data from TfL.
    </div>
  </div>

  <!-- Add Journey Modal -->
  <div id="addModal" class="modalBackdrop">
    <div class="modal">
      <div class="modalHeader">
        <div class="h">Add board</div>
        <button class="smallBtn" id="closeModalBtn">✕</button>
      </div>

      <div class="modalGrid">
        <div class="field">
          <div class="fieldLabel">Departure</div>
          <input class="input" id="fromInput" placeholder="Enter departure station" autocomplete="off" />
          <div class="results" id="fromResults" style="display:none;"></div>
        </div>

        <div class="field" id="toField">
          <div class="fieldLabel">Arrival</div>
          <input class="input" id="toInput" placeholder="Enter arrival station" autocomplete="off" />
          <div class="results" id="toResults" style="display:none;"></div>
        </div>

        <label class="checkRow">
          <input type="checkbox" id="showAllCb" />
          <div>
            <div class="txt">Show all departures</div>
            <div class="sub">Don’t filter by destination (useful for big stations)</div>
          </div>
        </label>

        <div class="row" style="justify-content:flex-end;">
          <button class="smallBtn ghostBtn" id="cancelAddBtn">Cancel</button>
          <button class="primary smallBtn" id="doneAddBtn" disabled>Done</button>
        </div>

        <div class="footerNote">
          Tip: pick stations from the suggestions to avoid typos. Non-favourited boards expire after 24h.
        </div>
      </div>
    </div>
  </div>

<script>
/**
 * London Departure Boards (GitHub Pages preview)
 * Uses your Cloudflare Worker to hide TfL keys.
 *
 * Required Worker endpoints:
 *   GET  /stations/search?q=...            -> { matches: [{id,name,modes?}, ...] }
 *   GET  /arrivals?stopPointId=...         -> { arrivals: [...] }
 *
 * Optional (recommended):
 *   GET  /lineStatus?modes=tube,dlr,...    -> { lines: [{id,name,status}], updatedAt }
 *   GET  /journey/last?fromId=...&toId=... -> { lastDepart, lastArrive }
 */

// ========= CONFIG =========
const API_BASE = "https://departure-board-api.ryancmolloy.workers.dev"; // no trailing slash
const AUTO_REFRESH_SECONDS = 25;
const LINE_STATUS_REFRESH_SECONDS = 120;
const MAX_DEPARTURES = 4;
const EXPIRY_MS = 24 * 60 * 60 * 1000; // 24h

// Ticker speed target:
const TICKER_CHARS_PER_SECOND = 3;

// TfL Tube map: open official page (no embedding/caching)
const TUBE_MAP_URL = "https://tfl.gov.uk/maps/track/tube";

// Minimal station list for nearest-station demo (best-effort).
const STATIONS_FOR_NEAREST = [
  { name: "Woolwich (Elizabeth line)", id: "910GWOLWXR", lat: 51.4919, lon: 0.0712 },
  { name: "Canary Wharf (Elizabeth line)", id: "910GCANWHRF", lat: 51.5036, lon: -0.0199 },
  { name: "Liverpool Street", id: "910GLIVST", lat: 51.5178, lon: -0.0824 },
  { name: "Paddington", id: "910GPADTON", lat: 51.5154, lon: -0.1755 },
  { name: "Waterloo", id: "910GWATRLMN", lat: 51.5033, lon: -0.1147 },
  { name: "London Bridge", id: "910GLNDBRDG", lat: 51.5054, lon: -0.0865 },
];

const STORAGE_KEY = "ldb_boards_v3";

// ========= STATE =========
let boards = []; // ordered list
let timer = null;
let tickerTimer = null;

let addDraft = {
  from: null, // {id,name}
  to: null,   // {id,name} optional if showAll === true
  showAll: false
};

let fromSearchTimer = null;
let toSearchTimer = null;

// drag state
let dragId = null;

// ========= ELEMENTS =========
const statusText = document.getElementById("statusText");
const pulseDot = document.getElementById("pulseDot");
document.getElementById("refreshEvery").textContent = `${AUTO_REFRESH_SECONDS}s`;

const boardsEl = document.getElementById("boards");

const addBtn = document.getElementById("addBtn");
const nearestBtn = document.getElementById("nearestBtn");
const tubeMapBtn = document.getElementById("tubeMapBtn");

const addModal = document.getElementById("addModal");
const closeModalBtn = document.getElementById("closeModalBtn");
const cancelAddBtn = document.getElementById("cancelAddBtn");
const doneAddBtn = document.getElementById("doneAddBtn");

const fromInput = document.getElementById("fromInput");
const toInput = document.getElementById("toInput");
const fromResults = document.getElementById("fromResults");
const toResults = document.getElementById("toResults");
const showAllCb = document.getElementById("showAllCb");
const toField = document.getElementById("toField");

const tickerWrap = document.getElementById("tickerWrap");
const tickerTrack = document.getElementById("tickerTrack");
const tickerMeta = document.getElementById("tickerMeta");

// ========= UI HELPERS =========
function setStatus(msg){ statusText.textContent = msg; }
function pulse(active){ pulseDot.style.background = active ? "var(--ok)" : "var(--muted)"; }

function escapeHtml(s){
  return String(s)
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

function fmtClock(dt){
  const d = new Date(dt);
  const hh = String(d.getHours()).padStart(2,'0');
  const mm = String(d.getMinutes()).padStart(2,'0');
  return `${hh}:${mm}`;
}

function minutesFromNow(dt){
  const ms = new Date(dt).getTime() - Date.now();
  const mins = Math.round(ms / 60000);
  return mins <= 0 ? "Due" : `${mins} min`;
}

function haversineMeters(aLat,aLon,bLat,bLon){
  const R = 6371000;
  const toRad = x => x * Math.PI / 180;
  const dLat = toRad(bLat - aLat);
  const dLon = toRad(bLon - aLon);
  const lat1 = toRad(aLat);
  const lat2 = toRad(bLat);
  const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
  return 2 * R * Math.asin(Math.sqrt(s));
}

// normalise station names for lenient destination matching
function normStationName(s){
  return (s || "")
    .toLowerCase()
    .replace(/\(.*?\)/g, "")      // remove bracketed qualifiers
    .replace(/station/g, "")      // remove "station"
    .replace(/underground/g, "")
    .replace(/rail/g, "")
    .replace(/elizabeth line/g, "")
    .replace(/dlr/g, "")
    .replace(/overground/g, "")
    .replace(/[\.\,]/g, "")
    .replace(/\s+/g, " ")
    .trim();
}

// ========= STORAGE =========
function loadBoards(){
  try{
    const raw = localStorage.getItem(STORAGE_KEY);
    const arr = raw ? JSON.parse(raw) : [];
    const now = Date.now();

    boards = (Array.isArray(arr) ? arr : [])
      .filter(b => b && b.id && b.fromId)
      .filter(b => b.favourite || (now - (b.createdAt || 0)) < EXPIRY_MS);

    boards.forEach(b => {
      if (typeof b.collapsed !== "boolean") b.collapsed = false;
      if (typeof b.favourite !== "boolean") b.favourite = false;
      if (!b.createdAt) b.createdAt = Date.now();
      if (typeof b.showAll !== "boolean") b.showAll = false;
      if (!b.toId) b.toId = null;
      if (!b.toName) b.toName = "";
    });

    saveBoards();
  }catch(e){
    boards = [];
  }
}

function saveBoards(){
  localStorage.setItem(STORAGE_KEY, JSON.stringify(boards));
}

// ========= API =========
async function apiStationsSearch(q){
  const res = await fetch(`${API_BASE}/stations/search?q=${encodeURIComponent(q)}`, { cache: "no-store" });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const data = await res.json();
  return Array.isArray(data.matches) ? data.matches : [];
}

async function apiArrivals(stopPointId){
  const res = await fetch(`${API_BASE}/arrivals?stopPointId=${encodeURIComponent(stopPointId)}`, { cache: "no-store" });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const payload = await res.json();
  const arr = Array.isArray(payload.arrivals) ? payload.arrivals : [];
  arr.sort((a,b) => new Date(a.expectedArrival) - new Date(b.expectedArrival));
  return arr;
}

async function apiLineStatus(){
  const modes = "tube,dlr,overground,elizabeth-line";
  const res = await fetch(`${API_BASE}/lineStatus?modes=${encodeURIComponent(modes)}`, { cache: "no-store" });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const data = await res.json();
  return {
    updatedAt: data.updatedAt || null,
    lines: Array.isArray(data.lines) ? data.lines : []
  };
}

async function apiLastJourney(fromId, toId){
  const res = await fetch(`${API_BASE}/journey/last?fromId=${encodeURIComponent(fromId)}&toId=${encodeURIComponent(toId)}`, { cache: "no-store" });
  if (!res.ok) throw new Error(`HTTP ${res.status}`);
  const data = await res.json();
  return {
    lastDepart: data.lastDepart || null,
    lastArrive: data.lastArrive || null
  };
}

// ========= RENDER =========
function render(){
  boardsEl.innerHTML = "";

  if (boards.length === 0){
    boardsEl.innerHTML = `
      <div class="board">
        <div class="boardHeader">
          <div class="left">
            <div class="name">Add your first board</div>
            <div class="meta"><span>Tap <strong>+</strong> to create a journey board.</span></div>
          </div>
          <div class="right">
            <button class="primary smallBtn" onclick="openAddModal()">Add journey</button>
          </div>
        </div>
        <div class="boardBody">
          <table class="table">
            <tr>
              <td>
                <div class="dest">Example</div>
                <div class="subline">Woolwich → Green Park · ★ favourite boards persist · drag boards to reorder</div>
              </td>
              <td class="time">—</td>
            </tr>
          </table>
        </div>
      </div>
    `;
    return;
  }

  for (const b of boards){
    const card = document.createElement("section");
    card.className = `board ${b.collapsed ? "collapsed" : ""}`;
    card.dataset.id = b.id;
    card.draggable = true;

    const title = b.showAll
      ? `${b.fromName} — All departures`
      : `${b.fromName} to ${b.toName}`;

    card.innerHTML = `
      <div class="boardHeader" title="Drag to reorder · Tap left area to collapse/expand">
        <div class="left collapseToggle">
          <div class="name">${escapeHtml(title)}</div>
          <div class="meta">
            <span>${b.favourite ? "<span class='ok'>★ Favourite</span>" : "Not favourited (expires in 24h)"}</span>
            <span id="meta-${b.id}">—</span>
          </div>
        </div>
        <div class="right">
          <button class="smallBtn" id="fav-${b.id}" title="Add/remove favourite">${b.favourite ? "★" : "☆"}</button>
          <button class="smallBtn ghostBtn" id="del-${b.id}" title="Delete">Delete</button>
        </div>
      </div>

      <div class="boardBody">
        <table class="table" id="table-${b.id}">
          <tr><td><span class="warn">Loading…</span><div class="subline">Fetching departures.</div></td><td class="time">—</td></tr>
        </table>
      </div>

      <div class="boardFooter" id="foot-${b.id}">
        <span class="badge">Last train today: <strong id="last-${b.id}">—</strong></span>
        <span class="badge">Current frequency: <strong id="freq-${b.id}">—</strong></span>
      </div>
    `;

    // Collapse toggle (left side only)
    card.querySelector(".collapseToggle").addEventListener("click", (e) => {
      e.stopPropagation();
      b.collapsed = !b.collapsed;
      saveBoards();
      render();
    });

    // Favourite toggle
    card.querySelector(`#fav-${CSS.escape(b.id)}`).addEventListener("click", (e) => {
      e.stopPropagation();
      b.favourite = !b.favourite;
      if (b.favourite) b.createdAt = Date.now();
      saveBoards();
      render();
      refreshBoard(b, true);
    });

    // Delete
    card.querySelector(`#del-${CSS.escape(b.id)}`).addEventListener("click", (e) => {
      e.stopPropagation();
      boards = boards.filter(x => x.id !== b.id);
      saveBoards();
      render();
    });

    // Drag & drop handlers
    setupDragHandlers(card);

    boardsEl.appendChild(card);
  }
}

function setupDragHandlers(card){
  const id = card.dataset.id;
  card.addEventListener("dragstart", (e) => {
    dragId = id;
    card.classList.add("dragging");
    e.dataTransfer.effectAllowed = "move";
    try { e.dataTransfer.setData("text/plain", id); } catch {}
  });

  card.addEventListener("dragend", () => {
    dragId = null;
    card.classList.remove("dragging");
    document.querySelectorAll(".board.dropTarget").forEach(el => el.classList.remove("dropTarget"));
  });

  card.addEventListener("dragover", (e) => {
    e.preventDefault();
    if (!dragId || dragId === id) return;
    card.classList.add("dropTarget");
    e.dataTransfer.dropEffect = "move";
  });

  card.addEventListener("dragleave", () => {
    card.classList.remove("dropTarget");
  });

  card.addEventListener("drop", (e) => {
    e.preventDefault();
    card.classList.remove("dropTarget");

    const srcId = dragId || (()=>{
      try { return e.dataTransfer.getData("text/plain"); } catch { return null; }
    })();
    const dstId = id;
    if (!srcId || !dstId || srcId === dstId) return;

    const srcIdx = boards.findIndex(b => b.id === srcId);
    const dstIdx = boards.findIndex(b => b.id === dstId);
    if (srcIdx < 0 || dstIdx < 0) return;

    const [moved] = boards.splice(srcIdx, 1);
    boards.splice(dstIdx, 0, moved);

    saveBoards();
    render();
    refreshAll(true);
  });
}

// ========= BOARD DATA POPULATION =========
function renderDeparturesTable(tableEl, arrivals, board){
  tableEl.innerHTML = "";

  if (!arrivals || arrivals.length === 0){
    tableEl.innerHTML = `<tr><td><span class="warn">No departures found.</span><div class="subline">Try refresh.</div></td><td class="time">—</td></tr>`;
    return;
  }

  // Always show something. If destination matching fails, fall back to all.
  let items = arrivals;

  let usedFallback = false;
  if (!board.showAll && board.toName){
    const target = normStationName(board.toName);

    const strict = arrivals.filter(it => {
      const dest = normStationName(it.destinationName || it.towards || "");
      return dest.includes(target) || target.includes(dest);
    });

    // If strict yields nothing, try a softer token match:
    let soft = strict;
    if (soft.length === 0 && target.length >= 3){
      const tokens = target.split(" ").filter(t => t.length >= 3);
      soft = arrivals.filter(it => {
        const dest = normStationName(it.destinationName || it.towards || "");
        return tokens.some(t => dest.includes(t));
      });
    }

    if (soft.length > 0){
      items = soft;
    } else {
      items = arrivals; // fallback
      usedFallback = true;
    }
  }

  items = items.slice(0, MAX_DEPARTURES);

  for (const it of items){
    const dest = it.destinationName || it.towards || "Unknown destination";
    const lineName = it.lineName || it.lineId || "Unknown line";
    const platform = it.platformName ? `Platform ${String(it.platformName).replace(/^Platform\s+/i,"")}` : null;

    const timeText = minutesFromNow(it.expectedArrival);
    const subBits = [lineName];
    if (platform) subBits.push(platform);

    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td>
        <div class="dest">${escapeHtml(dest)}</div>
        <div class="subline">${subBits.map(escapeHtml).join(" · ")}</div>
      </td>
      <td class="time">${escapeHtml(timeText)}</td>
    `;
    tableEl.appendChild(tr);
  }

  if (usedFallback){
    // Add a subtle footer row so users understand why it’s not “to X”
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td colspan="2">
        <div class="subline">
          Showing <strong>all departures</strong> (couldn’t confidently match destination).
        </div>
      </td>
    `;
    tableEl.appendChild(tr);
  }
}

function estimateFrequency(arrivals){
  // Best-effort: take first 3 departures and compute headway
  if (!arrivals || arrivals.length < 2) return null;
  const times = arrivals.slice(0, 4).map(x => new Date(x.expectedArrival).getTime()).filter(Number.isFinite);
  if (times.length < 2) return null;

  times.sort((a,b)=>a-b);
  const diffs = [];
  for (let i=1;i<times.length;i++){
    diffs.push((times[i]-times[i-1]) / 60000);
  }
  const avg = diffs.reduce((a,b)=>a+b,0) / diffs.length;
  if (!isFinite(avg) || avg <= 0) return null;
  const rounded = Math.max(1, Math.round(avg));
  return `1 train every ${rounded} min${rounded===1?"":"s"}`;
}

async function refreshBoard(b, manual=false){
  const metaEl = document.getElementById(`meta-${b.id}`);
  const tableEl = document.getElementById(`table-${b.id}`);
  const lastEl = document.getElementById(`last-${b.id}`);
  const freqEl = document.getElementById(`freq-${b.id}`);

  if (!tableEl) return;

  try{
    const arrivals = await apiArrivals(b.fromId);
    renderDeparturesTable(tableEl, arrivals, b);

    const freq = estimateFrequency(arrivals);
    freqEl.textContent = freq || "—";

    // Last train today: only meaningful if a destination is selected and showAll is false
    if (!b.showAll && b.toId){
      try{
        const last = await apiLastJourney(b.fromId, b.toId);
        if (last.lastDepart){
          lastEl.textContent = fmtClock(last.lastDepart);
        } else {
          lastEl.textContent = "—";
        }
      }catch(_){
        lastEl.textContent = "—";
      }
    } else {
      lastEl.textContent = "—";
    }

    if (metaEl){
      metaEl.textContent = `Updated ${fmtClock(new Date())}`;
    }
  }catch(e){
    if (metaEl) metaEl.textContent = "Update failed";
    tableEl.innerHTML = `<tr><td><span class="warn">Couldn’t load departures.</span><div class="subline">${escapeHtml(e.message || e)}</div></td><td class="time">—</td></tr>`;
  }
}

async function refreshAll(manual=false){
  if (boards.length === 0){
    setStatus("Idle");
    pulse(false);
    return;
  }

  setStatus(manual ? "Refreshing…" : "Auto-refreshing…");
  pulse(true);

  try{
    for (const b of boards){
      if (b.collapsed) continue;
      await refreshBoard(b, manual);
    }
    setStatus(`Updated ${fmtClock(new Date())}`);
  }finally{
    pulse(false);
  }
}

// ========= LINE STATUS TICKER =========
function computeTickerDurationFromText(text){
  const chars = (text || "").length;
  // duration seconds = chars / charsPerSecond; apply floor/ceil bounds so it never gets silly
  const secs = Math.min(180, Math.max(30, Math.round(chars / TICKER_CHARS_PER_SECOND)));
  document.documentElement.style.setProperty("--tickerDuration", `${secs}s`);
}

function renderTicker(lines, updatedAt){
  if (!lines || lines.length === 0){
    tickerWrap.style.display = "none";
    return;
  }

  tickerWrap.style.display = "";
  tickerMeta.textContent = updatedAt ? `Updated ${fmtClock(updatedAt)}` : "Updated recently";

  const items = lines.map(l => {
    const s = String(l.status || "").toLowerCase();
    const good = s.includes("good") || s.includes("running") || s.includes("service");
    const cls = good ? "statusGood" : "statusBad";
    return `${l.name}: ${l.status || "—"}`;
  });

  const text = items.join("   •   ");
  computeTickerDurationFromText(text);

  const html = lines.map(l => {
    const s = String(l.status || "").toLowerCase();
    const good = s.includes("good") || s.includes("running") || s.includes("service");
    const cls = good ? "statusGood" : "statusBad";
    return `<span class="tickerItem">${escapeHtml(l.name)}: <span class="${cls}">${escapeHtml(l.status || "—")}</span></span>`;
  }).join("");

  // Duplicate content for seamless loop
  tickerTrack.innerHTML = html + html;
}

async function refreshTicker(){
  try{
    const { updatedAt, lines } = await apiLineStatus();
    renderTicker(lines, updatedAt ? new Date(updatedAt) : null);
  }catch(_){
    tickerWrap.style.display = "none";
  }
}

// ========= ADD JOURNEY FLOW =========
function openAddModal(){
  addDraft = { from: null, to: null, showAll: false };
  fromInput.value = "";
  toInput.value = "";
  fromResults.style.display = "none";
  toResults.style.display = "none";
  fromResults.innerHTML = "";
  toResults.innerHTML = "";
  showAllCb.checked = false;
  toField.style.display = "";
  doneAddBtn.disabled = true;
  addModal.style.display = "block";
  fromInput.focus();
}

function closeAddModal(){
  addModal.style.display = "none";
}

function updateDoneButton(){
  if (!addDraft.from) {
    doneAddBtn.disabled = true;
    return;
  }
  if (addDraft.showAll) {
    doneAddBtn.disabled = false;
    return;
  }
  doneAddBtn.disabled = !(addDraft.from && addDraft.to);
}

function renderSearchResults(container, results, onPick){
  if (!results || results.length === 0){
    container.style.display = "none";
    container.innerHTML = "";
    return;
  }
  container.style.display = "";
  container.innerHTML = results.slice(0, 10).map(r => `
    <div class="resultItem" data-id="${escapeHtml(r.id)}" data-name="${escapeHtml(r.name)}">
      <strong>${escapeHtml(r.name)}</strong><br>
      <small>${escapeHtml((r.modes || []).join(", "))}</small>
    </div>
  `).join("");

  container.querySelectorAll(".resultItem").forEach(el => {
    el.addEventListener("click", () => {
      onPick({ id: el.getAttribute("data-id"), name: el.getAttribute("data-name") });
    });
  });
}

function debounceSearch(which, q){
  const run = async () => {
    q = (q || "").trim();
    if (q.length < 2){
      if (which === "from"){
        renderSearchResults(fromResults, [], ()=>{});
      }else{
        renderSearchResults(toResults, [], ()=>{});
      }
      return;
    }
    try{
      const matches = await apiStationsSearch(q);
      if (which === "from"){
        renderSearchResults(fromResults, matches, (pick) => {
          addDraft.from = pick;
          fromInput.value = pick.name;
          fromResults.style.display = "none";
          updateDoneButton();
        });
      }else{
        renderSearchResults(toResults, matches, (pick) => {
          addDraft.to = pick;
          toInput.value = pick.name;
          toResults.style.display = "none";
          updateDoneButton();
        });
      }
    }catch(e){
      // keep quiet
    }
  };

  if (which === "from"){
    clearTimeout(fromSearchTimer);
    fromSearchTimer = setTimeout(run, 250);
  }else{
    clearTimeout(toSearchTimer);
    toSearchTimer = setTimeout(run, 250);
  }
}

function addBoard(){
  if (!addDraft.from) return;
  if (!addDraft.showAll && !addDraft.to) return;

  const id = crypto.randomUUID ? crypto.randomUUID() : String(Date.now()) + Math.random().toString(16).slice(2);

  boards.unshift({
    id,
    fromId: addDraft.from.id,
    fromName: addDraft.from.name,
    toId: addDraft.showAll ? null : addDraft.to.id,
    toName: addDraft.showAll ? "" : addDraft.to.name,
    showAll: !!addDraft.showAll,
    favourite: false,
    createdAt: Date.now(),
    collapsed: false
  });

  saveBoards();
  closeAddModal();
  render();
  refreshAll(true);
}

// ========= NEAREST STATION =========
function setNearestFromLocation(){
  if (!navigator.geolocation){
    alert("Geolocation not supported in this browser.");
    return;
  }
  setStatus("Getting location…");
  pulse(true);
  navigator.geolocation.getCurrentPosition(
    async (pos) => {
      const { latitude, longitude } = pos.coords;

      let best = null;
      let bestD = Infinity;
      for (const s of STATIONS_FOR_NEAREST){
        const d = haversineMeters(latitude, longitude, s.lat, s.lon);
        if (d < bestD){ bestD = d; best = s; }
      }
      if (!best){
        alert("Couldn’t determine nearest station.");
        return;
      }

      const id = crypto.randomUUID ? crypto.randomUUID() : String(Date.now()) + Math.random().toString(16).slice(2);
      boards.unshift({
        id,
        fromId: best.id,
        fromName: best.name,
        toId: null,
        toName: "",
        showAll: true,
        favourite: false,
        createdAt: Date.now(),
        collapsed: false
      });

      saveBoards();
      render();
      await refreshAll(true);
    },
    () => alert("Location permission denied."),
    { enableHighAccuracy: false, timeout: 8000, maximumAge: 60000 }
  );
}

// ========= EVENTS =========
addBtn.addEventListener("click", openAddModal);
closeModalBtn.addEventListener("click", closeAddModal);
cancelAddBtn.addEventListener("click", closeAddModal);
doneAddBtn.addEventListener("click", addBoard);

fromInput.addEventListener("input", (e)=> debounceSearch("from", e.target.value));
toInput.addEventListener("input", (e)=> debounceSearch("to", e.target.value));

showAllCb.addEventListener("change", (e) => {
  addDraft.showAll = !!e.target.checked;
  if (addDraft.showAll){
    // arrival becomes optional; visually hide field
    toField.style.display = "none";
    addDraft.to = null;
    toInput.value = "";
    toResults.style.display = "none";
  } else {
    toField.style.display = "";
  }
  updateDoneButton();
});

nearestBtn.addEventListener("click", setNearestFromLocation);
tubeMapBtn.addEventListener("click", () => window.open(TUBE_MAP_URL, "_blank", "noopener,noreferrer"));

addModal.addEventListener("click", (e) => {
  if (e.target === addModal) closeAddModal();
});

// ========= TIMERS =========
function startTimers(){
  if (timer) clearInterval(timer);
  timer = setInterval(() => refreshAll(false), AUTO_REFRESH_SECONDS * 1000);

  if (tickerTimer) clearInterval(tickerTimer);
  tickerTimer = setInterval(() => refreshTicker(), LINE_STATUS_REFRESH_SECONDS * 1000);
}

// ========= INIT =========
loadBoards();
render();
refreshTicker();
refreshAll(false);
startTimers();
</script>

</body>
</html>
